### 练习

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点
 
#### 练习0：填写已有实验
本实验依赖实验 1/2/3。请把你做的实验 1/2/3 的代码填入本实验中代码中有“LAB1”,“LAB2”,“LAB3”的注释相应部分。

#### 练习 1：分配并初始化一个进程控制块（需要编码）
alloc_proc 函数（位于 kern/process/proc.c 中）负责分配并返回一个新的 struct proc_struct 结构，用于存储新建
立的内核线程的管理信息。ucore 需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。
【提示】在 alloc_proc 函数的实现中，需要初始化的 proc_struct 结构中的成员变量至少包括：
state/pid/runs/kstack/need_resched/parent/mm/context/tf/cr3/flags/name。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
• 请说明 proc_struct 中 struct context context 和 struct trapframe *tf 成员变量含义和
在本实验中的作用是啥？（提示通过看代码和编程调试可以判断出来）




#### 练习 2：为新创建的内核线程分配资源（需要编码）
创建一个内核线程需要分配和设置好很多资源。kernel_thread 函数通过调用 do_fork 函数完成具体内核线程
的创建工作。do_kernel 函数会调用 alloc_proc 函数来分配并初始化一个进程控制块，但 alloc_proc 只是找到
了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore 一般通过 do_fork 实际创建新的内
核线程。do_fork 的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存
储位置不同。因此，我们实际需要”fork”的东西就是 stack 和 trapframe。在这个过程中，需要给新内核线
程分配资源，并且复制原进程的状态。你需要完成在 kern/process/proc.c 中的 do_fork 函数中的处理过程。它
的大致执行步骤包括：
• 调用 alloc_proc，首先获得一块用户信息块。
• 为进程分配一个内核栈。
• 复制原进程的内存管理信息到新进程（但内核线程不必做此事）
• 复制原进程上下文到新进程
• 将新进程添加到进程列表
• 唤醒新进程
• 返回新进程号
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
• 请说明 ucore 是否做到给每个新 fork 的线程一个唯一的 id？请说明你的分析和理由。






#### 练习 3：编写 proc_run 函数（需要编码）
proc_run 用于将指定的进程切换到 CPU 上运行。它的大致执行步骤包括：
• 检查要切换的进程是否与当前正在运行的进程相同，如果相同则不需要切换。
• 禁 用 中 断。 你 可 以 使 用/kern/sync/sync.h 中 定 义 好 的 宏 local_intr_save(x) 和
local_intr_restore(x) 来实现关、开中断。
• 切换当前进程为要运行的进程。
• 切换页表，以便使用新进程的地址空间。/libs/riscv.h 中提供了 lcr3(unsigned int cr3)
函数，可实现修改 CR3 寄存器值的功能。
• 实现上下文切换。/kern/process 中已经预先编写好了 switch.S，其中定义了 switch_to() 函
数。可实现两个进程的 context 切换。
• 允许中断。
请回答如下问题：
• 在本实验的执行过程中，创建且运行了几个内核线程？
完成代码编写后，编译并运行代码：make qemu
如果可以得到如附录 A 所示的显示内容（仅供参考，不是标准答案输出），则基本正确。






#### 扩展练习 Challenge：
• 说明语句 local_intr_save(intr_flag);....local_intr_restore(intr_flag); 是如何实现开关中断的？
