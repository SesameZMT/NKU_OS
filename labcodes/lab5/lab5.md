### 练习

对实验报告的要求：
• 基于 markdown 格式来完成，以文本方式为主
• 填写各个基本练习中要求完成的报告内容
• 完成实验后，请分析 ucore_lab 中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
• 列出你认为本实验中重要的知识点，以及与对应的 OS 原理中的知识点，并简要说明你对二者的含义，
关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
• 列出你认为 OS 原理中很重要，但在实验中没有对应上的知识点
 

#### 练习0：填写已有实验
本实验依赖实验 1/2/3/4。请把你做的实验 1/2/3/4 的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”
/“LAB4”的注释相应部分。注意：为了能够正确执行 lab5 的测试应用程序，可能需对已完成的实验 1/2/3/4
的代码进行进一步改进。


#### 练习 1: 加载应用程序并执行（需要编码）
do_execv 函数调用 load_icode（位于 kern/process/proc.c 中）来加载并解析一个处于内存中的 ELF 执行文
件格式的应用程序。你需要补充 load_icode 的第 6 步，建立相应的用户内存空间来放置应用程序的代码
段、数据段等，且要设置好 proc_struct 结构中的成员变量 trapframe 中的内容，确保在执行此进程后，
能够从应用程序设定的起始执行地址开始执行。需设置正确的 trapframe 内容。
请在实验报告中简要说明你的设计实现过程。
• 请简要描述这个用户态进程被 ucore 选择占用 CPU 执行（RUNNING 态）到具体执行应用程序第一条
指令的整个经过。



#### 练习 2: 父进程复制自己的内存空间给子进程（需要编码）
创建子进程的函数 do_fork 在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新
进程中（子进程），完成内存资源的复制。具体是通过 copy_range 函数（位于 kern/mm/pmm.c 中）实现
的，请补充 copy_range 的实现，确保能够正确执行。
请在实验报告中简要说明你的设计实现过程。
• 如何设计实现 Copy on Write 机制？给出概要设计，鼓励给出详细设计。
Copy-on-write（简称 COW）的基本概念是指如果有多个使用者对一个资源 A（比如内存块）进行
读操作，则每个使用者只需获得一个指向同一个资源 A 的指针，就可以该资源了。若某使用者需
要对这个资源 A 进行写操作，系统会对该资源进行拷贝操作，从而使得该“写操作”使用者获得
一个该资源 A 的“私有”拷贝—资源 B，可对资源 B 进行写操作。该“写操作”使用者对资源 B
的改变对于其他的使用者而言是不可见的，因为其他使用者看到的还是资源 A。




#### 练习 3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不
需要编码）
请在实验报告中简要说明你对 fork/exec/wait/exit 函数的分析。并回答如下问题：
• 请分析 fork/exec/wait/exit 的执行流程。重点关注哪些操作是在用户态完成，哪些是在内核态完成？内核
态与用户态程序是如何交错执行的？内核态执行结果是如何返回给用户程序的？
• 请给出 ucore 中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及
产生变换的事件或函数调用）。（字符方式画即可）
执行：make grade。如果所显示的应用程序检测都输出 ok，则基本正确。（使用的是 qemu-1.0.1）


#### 扩展练习 Challenge：
1. 实现 Copy on Write （COW）机制
给出实现源码, 测试用例和设计报告（包括在 cow 情况下的各种状态转换（类似有限状态自动机）的说
明）。
这个扩展练习涉及到本实验和上一个实验“虚拟内存管理”。在 ucore 操作系统中，当一个用户父进程
创建自己的子进程时，父进程会把其申请的用户空间设置为只读，子进程可共享父进程占用的用户内
存空间中的页面（这就是一个共享的资源）。当其中任何一个进程修改此用户内存空间中的某页面时，
ucore 会通过 page fault 异常获知该操作，并完成拷贝内存页面，使得两个进程都有各自的内存页面。这
样一个进程所做的修改不会被另外一个进程可见了。请在 ucore 中实现这样的 COW 机制。
由于 COW 实现比较复杂，容易引入 bug，请参考 https://dirtycow.ninja/ 看看能否在 ucore 的 COW 实现
中模拟这个错误和解决方案。需要有解释。
这是一个 big challenge.
2. 说明该用户程序是何时被预先加载到内存中的？与我们常用操作系统的加载有何区别，原因是什么？

