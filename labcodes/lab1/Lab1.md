# 操作系统的中断



## 基础

### 概念
* CPU 收到中断指令后保存当前状态，开始处理其他事情。

### 功能
1. 增加CPU效率
2. 防止程序无限运行

### 进行中断处理支持的方法
* 编写相应的中断处理代码
* 在启动中正确设置控制寄存器
* CPU捕获异常
* 控制转交给相应中断处理代码进行处理
* 返回正在运行的程序



## 分类
1. 异常(Exception)：在执行一条指令的过程中发生了错误，此时通过中断来处理错误
2. 陷入(Trap)：主动通过一条指令停下来，并跳转到处理函数
3. 外部中断(Interrupt)： CPU 的执行过程被外设发来的信
号打断，此时必须先停下来对该外设进行处理



## riscv64 权限模式
1. M mode（机器模式）
    * 最高权限模式
    * 运行的 hart 对内存,I/O和一些对于启动和配置系统来说必要的底层功能有着完全的使用权
    * 发生异常控制权都会被移交到 M 模式的异常处理程序
    * 唯一所有标准 RISC-V 处理器都必须实现的权限模式

2. S mode（监督则模式）
    * 支持现代类 Unix 操作系统的权限模式
    * 核心：支持基于页面的虚拟内存机制



## 特权指令
* ecall：S态下执行进入 M 模式中的中断处理流程；U态下执行进入 S 模式中的中断处理流程
* sret：S 态中断返回到 U 态
* ebreak：触发一个断点中断从而进入中断处理流程
* mret：M 态中断返回到 S 态或 U 态



## 中断入口点
* 需求：把原先的寄存器保存下来，做完其他事情后把寄存器恢复
    
    将需要保存和回复的寄存器称为 ***上下文（context）*** 
* 实现上下文切换的步骤
    1. 保存 CPU 的上下文到内存中（栈上）
    2. 从内存中（栈上）恢复 CPU 的上下文

    定义结构体进行上下文数据管理



## 练习

### EXERCISE1
指令 `la sp, bootstacktop` 完成了将 `bootstacktop` 的地址加载到 `sp` (栈指针) 寄存器中的操作。目的是为了设置内核栈的起始地址，使得栈指针指向内核栈的顶部。
指令 `tail kern_init` 完成了跳转到 `kern_init` 函数的操作。目的是开始执行内核的初始化过程。使用 `tail` 指令而不是普通的跳转指令，是为了使得 `kern_init` 函数的返回地址仍然指向 `kern_entry`，以便在初始化完成后能够正确返回到 `kern_entry` 继续执行其他操作。


### EXERCISE2
添加代码如下
```c
void interrupt_handler(struct trapframe *tf) {
    intptr_t cause = (tf->cause << 1) >> 1;
    switch (cause) {
        /*
            其他case
        */

        case IRQ_S_TIMER:
            // "All bits besides SSIP and USIP in the sip register are
            // read-only." -- privileged spec1.9.1, 4.1.4, p59
            // In fact, Call sbi_set_timer will clear STIP, or you can clear it
            // directly.
            // cprintf("Supervisor timer interrupt\n");
             /* LAB1 EXERCISE2   YOUR CODE : 2111454 */
            /*(1)设置下次时钟中断- clock_set_next_event()
             *(2)计数器（ticks）加一
             *(3)当计数器加到100的时候，我们会输出一个`100ticks`表示我们触发了100次时钟中断，同时打印次数（num）加一
            * (4)判断打印次数，当打印次数为10时，调用<sbi.h>中的关机函数关机
            */
            clock_set_next_event();
            if(ticks++ % TICK_NUM == 0 && num < 10)
            {
                num++; //每打印一次计数器加一
                print_ticks(); //执行打印
            }
            else if(num == 10){
                sbi_shutdown(); //打印10次后调用<sbi.h>中的关机函数关机
            }
            break;

        /*
            其他case
        */
    }
}
```

运行结果如下：
![Alt text](<picture/LAB1 EXERCISE2运行结果.png>)


### CHALLENGE1
在 ucore 中处理中断异常的流程如下：
1. 异常的产生：当处理器执行指令时，如果遇到异常情况（例如除零错误、非法指令等），或者外部设备发送中断请求时，会触发中断异常。

2. 异常处理程序入口：当中断异常发生时，处理器会跳转到事先定义好的异常处理程序入口，即 `__alltraps`。

3. 保存现场：在 `__alltraps` 中，首先执行 `SAVE_ALL` 宏，将当前中断发生时的寄存器状态保存到栈中。`SAVE_ALL` 宏中的指令会将寄存器依次入栈，以保存现场信息。

4. 处理中断：接下来，根据中断类型，执行相应的中断处理程序。例如，如果是时钟中断，则执行时钟中断处理程序。

5. 恢复现场：在中断处理程序执行完毕后，需要恢复之前保存的现场信息。通过 `RESTORE_ALL` 宏，从栈中依次弹出寄存器值，恢复到中断发生时的状态。

6. 中断返回：最后，执行 `eret` 指令，将控制权返回到中断发生时的位置，继续执行被中断的指令。

在这个流程中，`mov a0, sp` 的目的是将当前栈顶指针值保存到 `a0` 寄存器中。这样做是为了在保存现场和恢复现场时，能够准确地找到栈中保存的寄存器值。

`SAVE_ALL` 中寄存器保存在栈中的位置是由编写异常处理程序时的约定来确定的。在 ucore 中，寄存器的保存顺序是按照 RISC-V 架构的规定，依次保存到栈中。

对于任何中断，`__alltraps` 中都需要保存所有寄存器，因为在中断处理过程中，可能会修改寄存器的值，如果不保存所有寄存器，就无法保证中断处理程序执行完毕后能够正确恢复被中断的代码的寄存器状态。因此，为了保证中断处理的正确性，需要保存所有寄存器的值。


### CHALLENGE2
汇编代码 `csrw sscratch, sp` 和 `csrrw s0, sscratch, x0` 实现了将栈指针 `sp` 的值保存到 `sscratch` 寄存器中，并将 `sscratch` 寄存器的值保存到 `s0` 寄存器中的操作。目的是为了在异常处理程序中能够正确地使用 `sscratch` 寄存器来保存一些临时数据或者状态。

在 `SAVE_ALL` 中，保存了 `stval` 和 `scause` 这些 CSR（Control and Status Registers）。这些 CSR 记录了当前异常的一些相关信息，比如异常的原因和异常发生时的地址。保存这些 CSR 的目的是为了在异常处理程序中能够获取异常的详细信息，以便进行适当的处理。

在 `RESTORE_ALL` 中，没有还原 `stval` 和 `scause` 这些 CSR 的值。这是因为在正常的异常处理过程中，这些 CSR 的值通常是只读的，不需要手动修改或还原。而且，在异常处理程序执行完毕后，处理器会自动根据异常发生时的现场信息将这些 CSR 恢复到正确的值。

尽管在 `RESTORE_ALL` 中没有还原这些 CSR 的值，但在 `SAVE_ALL` 中保存这些 CSR 的操作仍然有意义。这是因为在异常处理程序执行期间，如果需要访问这些 CSR 的值，可以通过读取 `sscratch` 寄存器的值来获取。这样做可以保存这些 CSR 的值，使它们不会因异常处理过程中的修改而被影响，保证了异常处理的正确性。