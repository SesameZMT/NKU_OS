### 练习

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点
 
#### 练习0：填写已有实验
本实验依赖实验1/2。请把你做的实验1/2的代码填入本实验中代码中有“LAB1”,“LAB2”的注释相应部分。

#### 练习1：理解基于FIFO的页面替换算法（思考题）
描述FIFO页面置换算法下，一个页面从被换入到被换出的过程中，会经过代码里哪些函数/宏的处理（或者说，需要调用哪些函数/宏），并用简单的一两句话描述每个函数在过程中做了什么？（为了方便同学们完成练习，所以实际上我们的项目代码和实验指导的还是略有不同，例如我们将FIFO页面置换算法头文件的大部分代码放在了`kern/mm/swap_fifo.c`文件中，这点请同学们注意）
 - 至少正确指出10个不同的函数分别做了什么？如果少于10个将酌情给分。我们认为只要函数原型不同，就算两个不同的函数。要求指出对执行过程有实际影响,删去后会导致输出结果不同的函数（例如assert）而不是cprintf这样的函数。如果你选择的函数不能完整地体现”从换入到换出“的过程，比如10个函数都是页面换入的时候调用的，或者解释功能的时候只解释了这10个函数在页面换入时的功能，那么也会扣除一定的分数

#### 练习2：深入理解不同分页模式的工作原理（思考题）
get_pte()函数（位于`kern/mm/pmm.c`）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。
 - get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
 - 目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

#### 练习3：给未被映射的地址映射上物理页（需要编程）
补充完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
 - 请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。
 - 如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
- 数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？

#### 练习4：补充完成Clock页替换算法（需要编程）
通过之前的练习，相信大家对FIFO的页面替换算法有了更深入的了解，现在请在我们给出的框架上，填写代码，实现 Clock页替换算法（mm/swap_clock.c）。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
 - 比较Clock页替换算法和FIFO算法的不同。

#### 练习5：阅读代码和实现手册，理解页表映射方式相关知识（思考题）
如果我们采用”一个大页“ 的页表映射方式，相比分级页表，有什么好处、优势，有什么坏处、风险？

#### 扩展练习 Challenge：实现不考虑实现开销和效率的LRU页替换算法（需要编程）
challenge部分不是必做部分，不过在正确最后会酌情加分。需写出有详细的设计、分析和测试的实验报告。完成出色的可获得适当加分。



虚拟内存系统中的页面错误（Page Fault）是指发生当程序尝试访问尚未载入物理内存的虚拟地址所对应的页时产生的异常。处理页面错误的一般流程如下：

    异常触发： 当程序尝试访问尚未加载到物理内存的虚拟页时，会触发页面错误异常。

    异常处理： 处理器捕获到这个异常，操作系统内核将负责处理异常。当发生页面错误时，处理器暂停当前程序的执行，并传递控制到操作系统内核。

    操作系统响应： 操作系统内核接管控制权，对页面错误进行处理。通常，操作系统会执行以下操作：

        确定缺页类型： 操作系统检查导致页面错误的原因，可以是缺页异常（缺少页表条目）或是非法访问（例如，对只读内存区域的写操作）等。

        加载缺页： 如果是缺页异常，操作系统会尝试将所需的页面加载到物理内存中。这可能涉及从磁盘上的交换空间中读取数据，或者是从其他存储设备加载页面数据。

        更新页表： 操作系统会更新页表，将虚拟地址映射到新加载到物理内存的页面。

        恢复执行： 当缺页处理完成后，操作系统允许被中断的程序继续执行。在操作系统加载了缺失的页面之后，处理器重新执行原来发生页面错误的指令。

    恢复执行： 一旦操作系统成功加载了缺页所需的页面，处理器恢复执行中断的程序。程序继续执行缺页引起异常的指令。




在操作系统中，页替换算法是用于管理虚拟内存的一部分。当所有物理页面（内存页）都已分配且需要为新的页面腾出空间时，页替换算法就会起作用。这种情况下，操作系统需要在内存中选择一个页面作为牺牲对象，即将其替换出去，以便为新的页面提供空间。

页替换算法的目标是尽可能地提高性能并减少页面错误的数量，同时遵守特定的替换策略。以下是一些常见的页替换算法：

    最佳（Optimal）替换算法： 选择未来最长时间内不会被使用的页面进行替换。这是理论上最佳的算法，但实际上很难在实时系统中实现，因为它需要对未来的页面访问模式有精确预测。

    先进先出（FIFO）替换算法： 将最早进入内存的页面替换出去。这种方法简单易实现，但可能会出现"Belady's Anomaly"（即在增加内存时，页面错误数反而会增加）。

    最近最久未使用（LRU）替换算法： 根据页面最近一次被访问的时间进行替换。LRU需要维护最近访问的记录，因此实现相对较为复杂。

    时钟（Clock）替换算法： 将页面组织为环形链表，使用一个指针按顺序扫描页面。当需要替换时，检查指针所指页面的访问位（是否被访问过），如果为0则替换；如果为1，则将访问位设为0并继续扫描。

    最少使用（LFU）替换算法： 替换最少被访问的页面。LFU需要维护页面被访问的次数，实现较为复杂。

在操作系统中，实现这些页替换算法通常需要使用数据结构（如栈、队列、链表或散列表）来追踪页面的使用情况，并为不同的算法选择最佳的数据结构。同时，页替换算法会影响系统的性能和页面错误率，因此选择合适的算法对系统的效率和资源利用非常重要。




多级页表是一种页表的组织结构，用于处理大型虚拟地址空间，其将整个虚拟地址空间分层管理，以便更有效地管理内存。当处理缺页异常时，多级页表需要执行以下步骤：

    页表查找： 当CPU试图访问一个虚拟地址时，硬件首先根据该虚拟地址检查页表。在多级页表中，需要进行多次查找才能定位到实际的物理地址。这些页表的层次结构可以是两级、三级或更多级，每一级页表指向下一级页表，直到找到最终的物理页框。

    缺页异常处理： 如果某个虚拟地址的页表项（Page Table Entry，PTE）没有被加载到内存中，会触发缺页异常。在这种情况下，操作系统会介入，根据缺页地址从磁盘或其他存储介质中加载相应的页面数据到物理内存中，并更新页表项，以便下一次访问时可以找到该地址对应的物理内存位置。

    页面置换算法： 如果没有空闲物理页来存储新加载的页面，需要进行页面置换。通过所选的页面置换算法（如LRU、FIFO、Clock等），从物理内存中选择一个牺牲页，释放其占用的物理内存页框。通常，牺牲页是根据特定的置换算法来确定的。这个页面会被写回磁盘，如果它是脏页（即已被修改），然后操作系统将新加载的页面放置在这个物理页框中，更新页表项，使其指向新的物理内存位置。

多级页表和页面置换算法相互配合，以便处理大型虚拟地址空间和管理内存页。这种方法可以提高系统的内存管理效率，同时也增加了硬件和操作系统的复杂性。选择合适的页表级数和页面置换算法，对于系统的性能和资源利用非常重要。


本次实验是在实验二的基础上，借助于页表机制和实验一中涉及的中断异常处理机制，完成Page Fault异常处理和部分页面替换算法的实现，结合磁盘提供的缓存空间，从而能够支持虚存管理，提供一个比实际物理内存空间“更大”的虚拟内存空间给系统使用。这个实验与实际操作系统中的实现比较起来要简单，不过需要了解实验一和实验二的具体实现。实际操作系统系统中的虚拟内存管理设计与实现是相当复杂的，涉及到与进程管理系统、文件系统等的交叉访问。如果大家有余力，可以尝试完成扩展练习，实现LRU页替换算法。

本实验依赖实验2。请把你做的实验2的代码填入本实验中代码中有“LAB2”的注释相应部分。（建议手动补充，不要直接使用merge）



理解基于FIFO的页面替换算法（思考题）

FIFO（First In, First Out）是最简单的页面替换算法之一，它按照页进入物理内存的顺序进行替换。当发生缺页异常且没有空闲物理页框可供使用时，FIFO算法选择最早进入内存的页面进行替换。

其实现方式是通过一个页表（FIFO队列）来维护物理内存中的页面顺序。当页面被载入内存时，加入队尾；当发生缺页异常时，从队头取出最早进入内存的页面进行替换。

下面是一个简单的伪代码示例：

```plaintext
1. 初始化FIFO队列为空
2. 缺页异常处理：
   a. 如果所需页面不在内存中（缺页）：
      i. 如果有空闲物理页框：
         a. 将所需页面加载到空闲物理页框中
         b. 将该物理页框添加到FIFO队列的尾部
      ii. 如果没有空闲物理页框：
         a. 从FIFO队列的头部取出最早进入的页面（最先进入内存的页面）
         b. 将该页面替换为新页面
         c. 将新页面加载到该物理页框中
         d. 更新页表

```

尽管FIFO算法实现简单，但其性能并不一定优于其他替换算法。因为FIFO算法没有考虑页面的访问频率，可能会导致“Belady异常”，即在页面数量增加时缺页率反而上升。其他替换算法，如LRU（Least Recently Used）考虑了页面的使用频率，因此通常会有更好的性能。

描述FIFO页面置换算法下，一个页面从被换入到被换出的过程中，会经过代码里哪些函数/宏的处理（或者说，需要调用哪些函数/宏），并用简单的一两句话描述每个函数在过程中做了什么？（为了方便同学们完成练习，所以实际上我们的项目代码和实验指导的还是略有不同，例如我们将FIFO页面置换算法头文件的大部分代码放在了kern/mm/swap_fifo.c文件中，这点请同学们注意）

在FIFO页面置换算法中，页面从被换入到被换出的过程会经过以下函数/宏的处理：

    _fifo_init_mm(struct mm_struct *mm): 用于初始化FIFO算法，管理所有可换出的页面。通过list_init初始化FIFO队列，并将mm->sm_priv指向pra_list_head。

    _fifo_map_swappable(struct mm_struct *mm, uintptr_t addr, struct Page *page, int swap_in): 将所需页面连接到pra_list_head的末尾，表示最近进入内存。通过list_add将页面添加到队列末尾。

    _fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, int in_tick): 根据FIFO算法，从队列前部取出最早进入内存的页面。通过list_prev取得队列的最早进入的页面，然后list_del移除该页面，将其地址设置到ptr_page指针中。

    _fifo_check_swap(): 一个测试函数，模拟了多次页面置换操作，进行了多次对不同内存地址的写入操作，模拟了缺页异常的过程。

这些函数包含了FIFO页面置换算法的关键逻辑，用于管理页面的进出过程以及置换逻辑，从而实现最先进入的页面最先被置换出去的策略。

至少正确指出10个不同的函数分别做了什么？如果少于10个将酌情给分。我们认为只要函数原型不同，就算两个不同的函数。要求指出对执行过程有实际影响,删去后会导致输出结果不同的函数（例如assert）而不是cprintf这样的函数。如果你选择的函数不能完整地体现”从换入到换出“的过程，比如10个函数都是页面换入的时候调用的，或者解释功能的时候只解释了这10个函数在页面换入时的功能，那么也会扣除一定的分数


深入理解不同分页模式的工作原理（思考题）

不同的分页模式指的是不同的虚拟内存管理方式。其中最常见的是分页式和段式。

    分页式（Paging）：
        工作原理： 将物理内存和虚拟内存分为固定大小的页面（通常为4KB或4MB），虚拟地址空间同样划分为相同大小的页。当程序需要访问内存时，CPU生成的虚拟地址被映射到物理地址。该映射是通过页表实现的，其中记录了虚拟页到物理页的映射关系。
        特点： 分页能够提供更大的地址空间，且页面之间是相互独立的。可以使用交换技术，允许部分页面不在物理内存中，而是存储在磁盘中。
    段式（Segmentation）：
        工作原理： 将内存划分为逻辑上独立的段，如代码段、数据段等。每个段的长度是不固定的，它们由段表进行映射。段表中包含了每个段的起始地址和长度。
        特点： 提供了更好的逻辑划分，允许程序员将程序划分为不同的逻辑段。然而，它对于地址空间的管理可能并不如分页灵活。

有些系统结合使用两种模式，如x86架构中使用了分段和分页相结合的模式，称为分段分页式。这种模式同时利用了分段的逻辑划分和分页的地址翻译。

get_pte()函数（位于kern/mm/pmm.c）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。

get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？

在RISC-V中，不同的页表级别使用了不同数量的页表项（Page Table Entry, PTE）来对虚拟地址进行翻译。

    sv32、sv39和sv48的异同：
        这三个术语分别代表了RISC-V中不同的地址翻译方案。sv32是32位的，分3级页表；sv39是39位的，分4级页表；sv48是48位的，也分4级页表。这些术语中的“sv”代表着“Supervisor Virtual Address Space”。
        这些页表不同之处在于每个页表项的大小、页表的级数以及每级页表所能表示的地址范围。sv32表示每级页表包含10位的页表项索引，sv39和sv48分别有9位和9位半。sv32有3级页表，而sv39和sv48都是4级页表。
        每个页表项所包含的字段可能略有不同，但其基本结构类似，例如PTE_P（是否存在）、PTE_W（是否可写）、PTE_U（是否用户可访问）等字段。

    get_pte()函数中的相似段：
        这两段代码在不同级的页表中起到了相似的作用，即检索对应虚拟地址的页表项。第一段代码针对的是一级页表（PDE），而第二段则是针对第二级页表（PTE）。
        其相似性在于两个级别的页表查找与分配都是由相似的操作步骤完成。它们都会检查目标页表项是否存在，如果不存在则创建该页表项，并进行相应的内存分配以建立对应的映射关系。

    是否将两个功能拆分：
        将页表项的查找和分配分开是一种更模块化和清晰的设计，有助于提高代码的可读性和可维护性。这种拆分使得代码更易于理解和调试。
        然而，现有的设计在一定程度上将两个相关的操作合并在一个函数中，这有助于简化逻辑和提高代码效率，因为避免了在两个函数之间频繁的上下文切换。同时也节省了一些函数调用的开销。因此，在特定的应用场景下，这种设计可能更为有效。

综上所述，代码中将查找和分配页表项的功能合并在一个函数中，这种设计在逻辑和性能上有其优势，但对于代码的清晰度和可维护性来说，拆分这两个功能为两个独立的函数会更有帮助。


给未被映射的地址映射上物理页（需要编程）

步骤如下：

    分配一个物理页： 首先需要从物理页框池中分配一个物理页。这个物理页应该是未被使用的，并且能够被映射到当前需要进行映射的虚拟地址。

    构建页表项： 在适当的页表中，找到对应的页表项。通常这涉及到对多级页表结构进行访问，找到页表项的位置。这些页表项描述了虚拟地址到物理地址的映射关系。

    建立映射关系： 修改所找到的页表项，将其内容设置为指向刚分配的物理页的物理地址。这一步是建立虚拟地址和物理地址之间的映射关系。

    清除TLB（Translation Lookaside Buffer）中的缓存： 如果之前的虚拟地址和物理地址的映射关系已经被缓存在TLB中，需要将TLB中的对应条目清除，以确保新的映射关系可以立即生效。

    更新页面属性： 在建立完映射关系后，可能需要设置对应页表项的一些属性，例如标志位（例如读写标志、存在标志等）。

补充完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表。

请在实验报告中简要说明你的设计实现过程。请回答如下问题：

请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。
如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？